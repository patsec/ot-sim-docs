{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Operational Technology (OT) Simulator \u00b6 OT-sim is a set of modules that run simulated OT devices in VMs or containers. It allows researchers to represent a physical system, at scale, in a co-simulation environment for specific or system-wide testing and evaluation without impacting a real-world system. Over time, our goal is to include additional protocol support and hardware-in-the-loop capability. Getting Started Visit here to get started using OT-sim. The purpose of OT-sim is to support co-simulation of OT-based modules and related infrastructure for a variety of research purposes. To that end, all of the modules run as separate processes and communicate with each other using a common message bus to make up a device. The message bus then resembles the backplane for communication from a variety of modules as seen in real-world environments. However, in OT-sim, it is the communication environment where all modules interact with the simulation environment \u2014 management signals, as well as production messages, are passed over the message bus. Note This documentation assumes a general understanding of Operational Technology (OT) protocols and devices. The current set of OT-sim modules are categorized as CPU , protocol \u2014 Modbus and DNP3 are currently supported \u2014 I/O acting as a HELICS federate, and Logic . OT devices can include devices such as PLCs, protection relays, IEDs, RTUs, FEPs, etc. These devices are virtual representations and \u201cwalk the walk\u201d when it comes to protocol communication. The Message Bus utilizes ZeroMQ's PUB/SUB protocol to allow connected modules to publish messages for other modules to process. ZeroMQ allows the abstraction of the medium in which the message bus sends messages over, supporting IPC and Unix sockets for modules running in the same host and IP for modules running across distributed hosts. OT-sim supports a wide variety of programming languages; it is possible for modules to be written in their developer's language of choice. In addition, since each module runs as its own process, it is possible to have an OT-sim device comprised of modules written in different programming languages. In most cases, the combination of modules formed to create an OT-sim device will all run together as separate processes on the same host \u2014 e.g., within the same VM or container. However, the design of the message bus supports modules running across multiple hosts \u2014 e.g., using an IP-based ZeroMQ socket in place of an IPC- or file-based socket. Note A localized configuration file, in XML format, is used to describe each device. HELICS is used as the primary co-simulation platform for simulating physical processes that OT-sim devices would monitor and control, so to support this the I/O module acts as a HELICS federate to facilitate the exchange of data with other HELICS federates. As an analogy, the data exchanged between HELICS federates can be compared to the 4-20mA current loop process control signals between sensors, actuators, and controllers in actual processes. The logic module facilitates the use of custom logic provided at runtime via the device configuration file, avoiding the need for a custom compiled modules for different logic scripts. Custom logic is a set of simple mathematical or boolean expressions that are parsed, compiled, and evaluated against variables present in the logic module or values from other modules. The CPU module is required as part of any OT-sim device and will process the device configuration file and configure and deploy the additional modules accordingly, as well as collocate logs generated by all other modules.","title":"Operational Technology (OT) Simulator"},{"location":"#operational-technology-ot-simulator","text":"OT-sim is a set of modules that run simulated OT devices in VMs or containers. It allows researchers to represent a physical system, at scale, in a co-simulation environment for specific or system-wide testing and evaluation without impacting a real-world system. Over time, our goal is to include additional protocol support and hardware-in-the-loop capability. Getting Started Visit here to get started using OT-sim. The purpose of OT-sim is to support co-simulation of OT-based modules and related infrastructure for a variety of research purposes. To that end, all of the modules run as separate processes and communicate with each other using a common message bus to make up a device. The message bus then resembles the backplane for communication from a variety of modules as seen in real-world environments. However, in OT-sim, it is the communication environment where all modules interact with the simulation environment \u2014 management signals, as well as production messages, are passed over the message bus. Note This documentation assumes a general understanding of Operational Technology (OT) protocols and devices. The current set of OT-sim modules are categorized as CPU , protocol \u2014 Modbus and DNP3 are currently supported \u2014 I/O acting as a HELICS federate, and Logic . OT devices can include devices such as PLCs, protection relays, IEDs, RTUs, FEPs, etc. These devices are virtual representations and \u201cwalk the walk\u201d when it comes to protocol communication. The Message Bus utilizes ZeroMQ's PUB/SUB protocol to allow connected modules to publish messages for other modules to process. ZeroMQ allows the abstraction of the medium in which the message bus sends messages over, supporting IPC and Unix sockets for modules running in the same host and IP for modules running across distributed hosts. OT-sim supports a wide variety of programming languages; it is possible for modules to be written in their developer's language of choice. In addition, since each module runs as its own process, it is possible to have an OT-sim device comprised of modules written in different programming languages. In most cases, the combination of modules formed to create an OT-sim device will all run together as separate processes on the same host \u2014 e.g., within the same VM or container. However, the design of the message bus supports modules running across multiple hosts \u2014 e.g., using an IP-based ZeroMQ socket in place of an IPC- or file-based socket. Note A localized configuration file, in XML format, is used to describe each device. HELICS is used as the primary co-simulation platform for simulating physical processes that OT-sim devices would monitor and control, so to support this the I/O module acts as a HELICS federate to facilitate the exchange of data with other HELICS federates. As an analogy, the data exchanged between HELICS federates can be compared to the 4-20mA current loop process control signals between sensors, actuators, and controllers in actual processes. The logic module facilitates the use of custom logic provided at runtime via the device configuration file, avoiding the need for a custom compiled modules for different logic scripts. Custom logic is a set of simple mathematical or boolean expressions that are parsed, compiled, and evaluated against variables present in the logic module or values from other modules. The CPU module is required as part of any OT-sim device and will process the device configuration file and configure and deploy the additional modules accordingly, as well as collocate logs generated by all other modules.","title":"Operational Technology (OT) Simulator"},{"location":"configuration/","text":"Configuration \u00b6 The following example configuration file has been separated into sections related to the current supported message bus and modules with a link to each of their documentation pages. The complete configuration file can be found at patsec/ot-sim GitHub page. Note There are additional configuration examples available in the config directory and documented here . Message Bus \u00b6 <message-bus> <verbose>1</verbose> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> </message-bus> CPU Module \u00b6 <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> </cpu> Logic Module \u00b6 <logic> <period>1s</period> <program> <![CDATA[ counter = (counter + 1) * reset reset = counter == 50 ? 0 : 1 ]]> </program> <variables> <counter>0</counter> <reset>1</reset> </variables> </logic> Modbus Module \u00b6 <modbus name=\"outstation\" mode=\"server\"> <endpoint>127.0.0.1:5502</endpoint> <register type=\"input\"> <address>30000</address> <tag>counter</tag> </register> <register type=\"input\"> <address>30001</address> <tag>bus-692.voltage</tag> <scaling>-2</scaling> </register> <register type=\"input\"> <address>30002</address> <tag>line-650632.kW</tag> <scaling>-2</scaling> </register> <register type=\"holding\"> <address>40000</address> <tag>reset</tag> </register> <register type=\"holding\"> <address>40001</address> <tag>line-650632.closed</tag> </register> </modbus> DNP3 Module \u00b6 <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>127.0.0.1:20001</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"outstation-1\"> <local-address>10</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <svar>Group1Var1</svar> <evar>Group2Var1</evar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <svar>Group10Var2</svar> <evar>Group11Var2</evar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> </outstation> </dnp3> I/O Module \u00b6 <io name=\"ot-sim-io\"> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> <broker-endpoint>localhost</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kVAR</key> <type>double</type> <tag>line-650632.kVAR</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <subscription> <key>OpenDSS/switch-671692.closed</key> <type>boolean</type> <tag>switch-671692.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io>","title":"Configuration"},{"location":"configuration/#configuration","text":"The following example configuration file has been separated into sections related to the current supported message bus and modules with a link to each of their documentation pages. The complete configuration file can be found at patsec/ot-sim GitHub page. Note There are additional configuration examples available in the config directory and documented here .","title":"Configuration"},{"location":"configuration/#message-bus","text":"<message-bus> <verbose>1</verbose> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> </message-bus>","title":"Message Bus"},{"location":"configuration/#cpu-module","text":"<cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> </cpu>","title":"CPU Module"},{"location":"configuration/#logic-module","text":"<logic> <period>1s</period> <program> <![CDATA[ counter = (counter + 1) * reset reset = counter == 50 ? 0 : 1 ]]> </program> <variables> <counter>0</counter> <reset>1</reset> </variables> </logic>","title":"Logic Module"},{"location":"configuration/#modbus-module","text":"<modbus name=\"outstation\" mode=\"server\"> <endpoint>127.0.0.1:5502</endpoint> <register type=\"input\"> <address>30000</address> <tag>counter</tag> </register> <register type=\"input\"> <address>30001</address> <tag>bus-692.voltage</tag> <scaling>-2</scaling> </register> <register type=\"input\"> <address>30002</address> <tag>line-650632.kW</tag> <scaling>-2</scaling> </register> <register type=\"holding\"> <address>40000</address> <tag>reset</tag> </register> <register type=\"holding\"> <address>40001</address> <tag>line-650632.closed</tag> </register> </modbus>","title":"Modbus Module"},{"location":"configuration/#dnp3-module","text":"<dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>127.0.0.1:20001</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"outstation-1\"> <local-address>10</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <svar>Group1Var1</svar> <evar>Group2Var1</evar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <svar>Group10Var2</svar> <evar>Group11Var2</evar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> </outstation> </dnp3>","title":"DNP3 Module"},{"location":"configuration/#io-module","text":"<io name=\"ot-sim-io\"> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> <broker-endpoint>localhost</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kVAR</key> <type>double</type> <tag>line-650632.kVAR</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <subscription> <key>OpenDSS/switch-671692.closed</key> <type>boolean</type> <tag>switch-671692.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io>","title":"I/O Module"},{"location":"cpu/","text":"CPU Module \u00b6 Configuration Example \u00b6 Example section from configuration file: <cpu> <api-endpoint>127.0.0.1:9101</api-endpoint> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> </cpu> CPU Module Overview \u00b6 The CPU Module is the core module; in the example above , there are five separate modules configured for the CPU Module. The CPU Module starts and monitors all other modules. When other modules quit unexpectedly, they are restarted by the CPU. The CPU Module is the primary collection point for logs from other modules. The logs are written to the message bus for the CPU Module to collect; this is also true for health checks. Each module has an independent schema, which the CPU Module is not concerned with. There are three main functions for the CPU module: Start and stop other modules Collect and manage logs, which are currently written to the CPU module's STDOUT Collect and expose metrics, which are currently exposed at http://localhost:9100/metrics HTTP API \u00b6 The example above also includes <api-endpoint> , which, when provided, enables an API for interacting with the CPU module over HTTP. The API makes the following paths available. # list of all points currently known by the CPU module GET /api/v1/query # get WebSocket that will receive a list of points every 5s GET /api/v1/query/ws # get a specific point by tag name GET /api/v1/query/{tag} # send one or more points to be updated via JSON POST /api/v1/write # update specific point by tag name POST /api/v1/write/{tag}/{value} Tip The schema used to send and receive points is the same as what is used to send points over the message bus, documented here . TLS \u00b6 The CPU module can use Secure HTTP (HTTPS) to identify the CPU API server and encrypt the HTTP traffic by providing paths to an existing SSL certificate and key for the server. To do this, replace the <api-endpoint> element in the example above with the following configuration. <api> <endpoint>127.0.0.1:9100</endpoint> <tls-key>/path/to/tls.key</tls-key> <tls-certificate>/path/to/tls.crt</tls-certificate> </api> Mutual TLS \u00b6 It is also possible to require clients to authenticate with the CPU API server using TLS by adding an element to the <api> configuration example above. This element points to an existing SSL CA certificate used to sign the SSL certificate clients will use when connecting to the server. <api> <endpoint>127.0.0.1:9100</endpoint> <tls-key>/path/to/tls.key</tls-key> <tls-certificate>/path/to/tls.crt</tls-certificate> <ca-certificate>/path/to/ca.crt</ca-certificate> </api>","title":"CPU Module"},{"location":"cpu/#cpu-module","text":"","title":"CPU Module"},{"location":"cpu/#configuration-example","text":"Example section from configuration file: <cpu> <api-endpoint>127.0.0.1:9101</api-endpoint> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> </cpu>","title":"Configuration Example"},{"location":"cpu/#cpu-module-overview","text":"The CPU Module is the core module; in the example above , there are five separate modules configured for the CPU Module. The CPU Module starts and monitors all other modules. When other modules quit unexpectedly, they are restarted by the CPU. The CPU Module is the primary collection point for logs from other modules. The logs are written to the message bus for the CPU Module to collect; this is also true for health checks. Each module has an independent schema, which the CPU Module is not concerned with. There are three main functions for the CPU module: Start and stop other modules Collect and manage logs, which are currently written to the CPU module's STDOUT Collect and expose metrics, which are currently exposed at http://localhost:9100/metrics","title":"CPU Module Overview"},{"location":"cpu/#http-api","text":"The example above also includes <api-endpoint> , which, when provided, enables an API for interacting with the CPU module over HTTP. The API makes the following paths available. # list of all points currently known by the CPU module GET /api/v1/query # get WebSocket that will receive a list of points every 5s GET /api/v1/query/ws # get a specific point by tag name GET /api/v1/query/{tag} # send one or more points to be updated via JSON POST /api/v1/write # update specific point by tag name POST /api/v1/write/{tag}/{value} Tip The schema used to send and receive points is the same as what is used to send points over the message bus, documented here .","title":"HTTP API"},{"location":"cpu/#tls","text":"The CPU module can use Secure HTTP (HTTPS) to identify the CPU API server and encrypt the HTTP traffic by providing paths to an existing SSL certificate and key for the server. To do this, replace the <api-endpoint> element in the example above with the following configuration. <api> <endpoint>127.0.0.1:9100</endpoint> <tls-key>/path/to/tls.key</tls-key> <tls-certificate>/path/to/tls.crt</tls-certificate> </api>","title":"TLS"},{"location":"cpu/#mutual-tls","text":"It is also possible to require clients to authenticate with the CPU API server using TLS by adding an element to the <api> configuration example above. This element points to an existing SSL CA certificate used to sign the SSL certificate clients will use when connecting to the server. <api> <endpoint>127.0.0.1:9100</endpoint> <tls-key>/path/to/tls.key</tls-key> <tls-certificate>/path/to/tls.crt</tls-certificate> <ca-certificate>/path/to/ca.crt</ca-certificate> </api>","title":"Mutual TLS"},{"location":"dnp3/","text":"DNP3 Module \u00b6 Configuration Example \u00b6 Example section from configuration file: <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>127.0.0.1:20001</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"outstation-1\"> <local-address>10</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <sgvar>Group1Var1</sgvar> <egvar>Group2Var1</egvar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <sgvar>Group10Var2</sgvar> <egvar>Group11Var2</egvar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <sgvar>Group30Var6</sgvar> <egvar>Group32Var6</egvar> <class>Class1</class> </input> </outstation> </dnp3> These configuration keys are described below . DNP3 Module Overview \u00b6 The DNP3 Module can act as a DNP3 client or server. Each client can act as one or more DNP3 masters, and each server can act as one or more DNP3 outstations. A limitation is that currently, OT-sim only supports a single client connection per server. Another limitation would be support for just 32-bit analog, not 16- or 64-bit. Note OT-sim uses OpenDNP3 v3.1.2, please visit their content if you have questions on the library. Capabilities \u00b6 Handles select before operate Supports class scans Supports unsolicited responses Supports outstation restarts Supports binary inputs and outputs Default Values \u00b6 OT-sim supports all group and variation options that OpenDNP3 does. There are default settings if you do not specify a group and variation. The sgvar key is the static group variation and has the following default values: Binary input is group 1 variation 2 Analog input is group 30 variation 6 Binary output is none Analog output is none The egvar key is the event group variation and has the following default values: Binary input is group 2 variation 2 Analog input is group 32 variation 6 Binary output is none Analog output is none Select before operate \u2014 the sbo key \u2014 is a binary value and it defaults to false . The class key defaults to Class1 ; others are supported. Todo Additional class scan rate options available in the DNP3 module need to be documented.","title":"DNP3 Module"},{"location":"dnp3/#dnp3-module","text":"","title":"DNP3 Module"},{"location":"dnp3/#configuration-example","text":"Example section from configuration file: <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>127.0.0.1:20001</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"outstation-1\"> <local-address>10</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <sgvar>Group1Var1</sgvar> <egvar>Group2Var1</egvar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <sgvar>Group10Var2</sgvar> <egvar>Group11Var2</egvar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <sgvar>Group30Var6</sgvar> <egvar>Group32Var6</egvar> <class>Class1</class> </input> </outstation> </dnp3> These configuration keys are described below .","title":"Configuration Example"},{"location":"dnp3/#dnp3-module-overview","text":"The DNP3 Module can act as a DNP3 client or server. Each client can act as one or more DNP3 masters, and each server can act as one or more DNP3 outstations. A limitation is that currently, OT-sim only supports a single client connection per server. Another limitation would be support for just 32-bit analog, not 16- or 64-bit. Note OT-sim uses OpenDNP3 v3.1.2, please visit their content if you have questions on the library.","title":"DNP3 Module Overview"},{"location":"dnp3/#capabilities","text":"Handles select before operate Supports class scans Supports unsolicited responses Supports outstation restarts Supports binary inputs and outputs","title":"Capabilities"},{"location":"dnp3/#default-values","text":"OT-sim supports all group and variation options that OpenDNP3 does. There are default settings if you do not specify a group and variation. The sgvar key is the static group variation and has the following default values: Binary input is group 1 variation 2 Analog input is group 30 variation 6 Binary output is none Analog output is none The egvar key is the event group variation and has the following default values: Binary input is group 2 variation 2 Analog input is group 32 variation 6 Binary output is none Analog output is none Select before operate \u2014 the sbo key \u2014 is a binary value and it defaults to false . The class key defaults to Class1 ; others are supported. Todo Additional class scan rate options available in the DNP3 module need to be documented.","title":"Default Values"},{"location":"examples/","text":"Example Devices \u00b6 An OT-sim device comprises one or more modules connected to a message bus and is built via an XML configuration file. The configuration file describes all the modules used to make up the device and the configuration of each specific module. Below are examples of configurations showing how specific devices can be built using XML. Intelligent Electronic Device (IED) \u00b6 The term \"IED\" is typically used as an umbrella term for any digital control system field device capable of communication. Here we'll provide a configuration for a simple device that basically acts as an analog-to-digital converter between HELICS (a simulated physical process) and an OT protocol (Modbus). <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> </cpu> <modbus name=\"outstation\" mode=\"server\"> <endpoint>0.0.0.0:502</endpoint> <register type=\"coil\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"discrete\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"input\"> <address>30000</address> <tag>bus-692.voltage</tag> <scaling>-2</scaling> </register> <register type=\"input\"> <address>30001</address> <tag>line-650632.kW</tag> <scaling>-2</scaling> </register> </modbus> <io name=\"helics-federate\"> <broker-endpoint>localhost</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io> </ot-sim> Remote Telemetry Unit (RTU) \u00b6 The term \"RTU\" is sometimes used interchangeably with \"IED\". However, here we'll be using the term \"RTU\" to represent a device that's acting more like an OT protocol gateway or front-end processor, where it's receiving requests from one or more upstream devices using one protocol, but communicating with one or more downstream devices using a different protocol. <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> </cpu> <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>0.0.0.0:20000</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"outstation-1\"> <local-address>1024</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <svar>Group1Var1</svar> <evar>Group2Var1</evar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <svar>Group10Var2</svar> <evar>Group11Var2</evar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <input type=\"analog\"> <address>1</address> <tag>bus-692.voltage</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> </outstation> </dnp3> <modbus name=\"modbus-client\" mode=\"client\"> <endpoint>127.0.0.1:502</endpoint> <period>2s</period> <register type=\"coil\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"discrete\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"input\"> <address>30000</address> <tag>bus-692.voltage</tag> <scaling>2</scaling> </register> <register type=\"input\"> <address>30001</address> <tag>line-650632.kW</tag> <scaling>2</scaling> </register> </modbus> </ot-sim> Programmable Logic Controller (PLC) \u00b6 This configuration is an example of how a very simplistic PLC can be implemented using the OT-sim logic module to simulate the physics of a fluid tank process. The logic running in this \"PLC\" generates outputs and responds to inputs that might be present in an actual fluid tank process. The goal of this configuration is to demonstrate the current capabilities of the OT-sim logic module. Rather than measuring inlet and outlet flow, we're calculating them simply as part of the simulation. Simulation Parameters Max inlet flow 100 GPM Max outlet flow 125 GPM Tank capacity 10,000 gallons The percent-open value for the inlet and outlet valves is controllable. For example, if the tank level gets above 9,500 gallons, the inlet valve will close and will not open again until the tank level gets below 7,500 gallons. <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> </cpu> <logic name=\"PLC-tank-sim\"> <period>1s</period> <program> <![CDATA[ # stay in event state if level is not low enough event = event && level > 7_500 # only allow inlet valve to be opened again if not in event state setpoint = event ? 0 : inlet_pos inflow = ((100 / 60) * setpoint) outflow = ((125 / 60) * outlet_pos) # calculate current level of tank level = level + inflow - outflow level = level < 0 ? 0 : level # go into event state if tank level too high (or will be too high) event = event || (level + inflow) > 9_500 ]]> </program> <variables> <event>false</event> <level>0</level> <inlet_pos>1.0</inlet_pos> <outlet_pos>0.75</outlet_pos> </variables> <process-updates>true</process-updates> </logic> <modbus name=\"outstation\" mode=\"server\"> <endpoint>0.0.0.0:502</endpoint> <register type=\"discrete\"> <address>0</address> <tag>event</tag> </register> <register type=\"input\"> <address>30000</address> <tag>level</tag> <scaling>0</scaling> </register> <register type=\"holding\"> <address>40000</address> <tag>inlet_pos</tag> <scaling>-2</scaling> </register> <register type=\"holding\"> <address>40001</address> <tag>outlet_pos</tag> <scaling>-2</scaling> </register> </modbus> </ot-sim> Overcurrent Protection Relay \u00b6 This configuration is an example of how an (admittedly simple) overcurrent protection relay can be implemented using the OT-sim logic module. In this implementation, it is assumed that the I/O module provides the value of the current variable \u2014 i.e., from a HELICS federate. The value of the closed variable is monitored and processed by the I/O module to be published by a HELICS federate, and a protocol module can modify the current_max variable. Initially, the current will be less than the max current, so there will be no active event, and the counter will remain at zero. Therefore, the breaker will be closed initially and stay that way since the counter will be less than 5 . If the I/O module reports the current to be above the max current for longer than 5s, the closed variable would be set to zero, and the I/O module would process that update. (In this example, the logic is processed on a period of every 1s so that the counter would reach 5 in 5s.) Processing the update would cause the current variable to go to 0 , but the breaker would not close again until manually changed via some other means \u2014 i.e., simlar to a protocol module. <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> </cpu> <logic name=\"overcurrent-relay\"> <period>1s</period> <program> <![CDATA[ event = current > current_max ? 1 : 0 counter = (counter + 1) * event closed = closed == 0 || counter >= 5 ? 0 : 1 ]]> </program> <variables> <current tag=\"line-650632.kW\">100</current> <current_max tag=\"line-650632.kW_max\">150</current_max> <closed tag=\"line-650632.closed\">1</closed> </variables> </logic> <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>127.0.0.1:20000</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"dnp3-outstation\"> <local-address>1024</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <svar>Group1Var1</svar> <evar>Group2Var1</evar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <svar>Group10Var2</svar> <evar>Group11Var2</evar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <input type=\"analog\"> <address>1</address> <tag>line-650632.kVAR</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <input type=\"analog\"> <address>2</address> <tag>bus-692.voltage</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <output type=\"analog\"> <address>10</address> <tag>line-650632.kW_max</tag> <svar>Group40Var2</svar> <evar>Group41Var2</evar> <class>Class1</class> </input> </outstation> </dnp3> <io name=\"helics-federate\"> <broker-endpoint>127.0.0.1</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kVAR</key> <type>double</type> <tag>line-650632.kVAR</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io> </ot-sim>","title":"Example Devices"},{"location":"examples/#example-devices","text":"An OT-sim device comprises one or more modules connected to a message bus and is built via an XML configuration file. The configuration file describes all the modules used to make up the device and the configuration of each specific module. Below are examples of configurations showing how specific devices can be built using XML.","title":"Example Devices"},{"location":"examples/#intelligent-electronic-device-ied","text":"The term \"IED\" is typically used as an umbrella term for any digital control system field device capable of communication. Here we'll provide a configuration for a simple device that basically acts as an analog-to-digital converter between HELICS (a simulated physical process) and an OT protocol (Modbus). <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> </cpu> <modbus name=\"outstation\" mode=\"server\"> <endpoint>0.0.0.0:502</endpoint> <register type=\"coil\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"discrete\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"input\"> <address>30000</address> <tag>bus-692.voltage</tag> <scaling>-2</scaling> </register> <register type=\"input\"> <address>30001</address> <tag>line-650632.kW</tag> <scaling>-2</scaling> </register> </modbus> <io name=\"helics-federate\"> <broker-endpoint>localhost</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io> </ot-sim>","title":"Intelligent Electronic Device (IED)"},{"location":"examples/#remote-telemetry-unit-rtu","text":"The term \"RTU\" is sometimes used interchangeably with \"IED\". However, here we'll be using the term \"RTU\" to represent a device that's acting more like an OT protocol gateway or front-end processor, where it's receiving requests from one or more upstream devices using one protocol, but communicating with one or more downstream devices using a different protocol. <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> </cpu> <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>0.0.0.0:20000</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"outstation-1\"> <local-address>1024</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <svar>Group1Var1</svar> <evar>Group2Var1</evar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <svar>Group10Var2</svar> <evar>Group11Var2</evar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <input type=\"analog\"> <address>1</address> <tag>bus-692.voltage</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> </outstation> </dnp3> <modbus name=\"modbus-client\" mode=\"client\"> <endpoint>127.0.0.1:502</endpoint> <period>2s</period> <register type=\"coil\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"discrete\"> <address>0</address> <tag>line-650632.closed</tag> </register> <register type=\"input\"> <address>30000</address> <tag>bus-692.voltage</tag> <scaling>2</scaling> </register> <register type=\"input\"> <address>30001</address> <tag>line-650632.kW</tag> <scaling>2</scaling> </register> </modbus> </ot-sim>","title":"Remote Telemetry Unit (RTU)"},{"location":"examples/#programmable-logic-controller-plc","text":"This configuration is an example of how a very simplistic PLC can be implemented using the OT-sim logic module to simulate the physics of a fluid tank process. The logic running in this \"PLC\" generates outputs and responds to inputs that might be present in an actual fluid tank process. The goal of this configuration is to demonstrate the current capabilities of the OT-sim logic module. Rather than measuring inlet and outlet flow, we're calculating them simply as part of the simulation. Simulation Parameters Max inlet flow 100 GPM Max outlet flow 125 GPM Tank capacity 10,000 gallons The percent-open value for the inlet and outlet valves is controllable. For example, if the tank level gets above 9,500 gallons, the inlet valve will close and will not open again until the tank level gets below 7,500 gallons. <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"modbus\">ot-sim-modbus-module {{config_file}}</module> </cpu> <logic name=\"PLC-tank-sim\"> <period>1s</period> <program> <![CDATA[ # stay in event state if level is not low enough event = event && level > 7_500 # only allow inlet valve to be opened again if not in event state setpoint = event ? 0 : inlet_pos inflow = ((100 / 60) * setpoint) outflow = ((125 / 60) * outlet_pos) # calculate current level of tank level = level + inflow - outflow level = level < 0 ? 0 : level # go into event state if tank level too high (or will be too high) event = event || (level + inflow) > 9_500 ]]> </program> <variables> <event>false</event> <level>0</level> <inlet_pos>1.0</inlet_pos> <outlet_pos>0.75</outlet_pos> </variables> <process-updates>true</process-updates> </logic> <modbus name=\"outstation\" mode=\"server\"> <endpoint>0.0.0.0:502</endpoint> <register type=\"discrete\"> <address>0</address> <tag>event</tag> </register> <register type=\"input\"> <address>30000</address> <tag>level</tag> <scaling>0</scaling> </register> <register type=\"holding\"> <address>40000</address> <tag>inlet_pos</tag> <scaling>-2</scaling> </register> <register type=\"holding\"> <address>40001</address> <tag>outlet_pos</tag> <scaling>-2</scaling> </register> </modbus> </ot-sim>","title":"Programmable Logic Controller (PLC)"},{"location":"examples/#overcurrent-protection-relay","text":"This configuration is an example of how an (admittedly simple) overcurrent protection relay can be implemented using the OT-sim logic module. In this implementation, it is assumed that the I/O module provides the value of the current variable \u2014 i.e., from a HELICS federate. The value of the closed variable is monitored and processed by the I/O module to be published by a HELICS federate, and a protocol module can modify the current_max variable. Initially, the current will be less than the max current, so there will be no active event, and the counter will remain at zero. Therefore, the breaker will be closed initially and stay that way since the counter will be less than 5 . If the I/O module reports the current to be above the max current for longer than 5s, the closed variable would be set to zero, and the I/O module would process that update. (In this example, the logic is processed on a period of every 1s so that the counter would reach 5 in 5s.) Processing the update would cause the current variable to go to 0 , but the breaker would not close again until manually changed via some other means \u2014 i.e., simlar to a protocol module. <?xml version=\"1.0\"?> <ot-sim> <message-bus> <pull-endpoint>tcp://127.0.0.1:1234</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:5678</pub-endpoint> </message-bus> <cpu> <module name=\"backplane\">ot-sim-message-bus {{config_file}}</module> <module name=\"logic\">ot-sim-logic-module {{config_file}}</module> <module name=\"dnp3\">ot-sim-dnp3-module {{config_file}}</module> <module name=\"io\">ot-sim-io-module {{config_file}}</module> </cpu> <logic name=\"overcurrent-relay\"> <period>1s</period> <program> <![CDATA[ event = current > current_max ? 1 : 0 counter = (counter + 1) * event closed = closed == 0 || counter >= 5 ? 0 : 1 ]]> </program> <variables> <current tag=\"line-650632.kW\">100</current> <current_max tag=\"line-650632.kW_max\">150</current_max> <closed tag=\"line-650632.closed\">1</closed> </variables> </logic> <dnp3 name=\"dnp3-outstation\" mode=\"server\"> <endpoint>127.0.0.1:20000</endpoint> <cold-restart-delay>15</cold-restart-delay> <outstation name=\"dnp3-outstation\"> <local-address>1024</local-address> <remote-address>1</remote-address> <warm-restart-delay>5</warm-restart-delay> <input type=\"binary\"> <address>0</address> <tag>line-650632.closed</tag> <svar>Group1Var1</svar> <evar>Group2Var1</evar> <class>Class1</class> </input> <output type=\"binary\"> <address>10</address> <tag>line-650632.closed</tag> <svar>Group10Var2</svar> <evar>Group11Var2</evar> <class>Class1</class> <sbo>false</sbo> </output> <input type=\"analog\"> <address>0</address> <tag>line-650632.kW</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <input type=\"analog\"> <address>1</address> <tag>line-650632.kVAR</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <input type=\"analog\"> <address>2</address> <tag>bus-692.voltage</tag> <svar>Group30Var6</svar> <evar>Group32Var6</evar> <class>Class1</class> </input> <output type=\"analog\"> <address>10</address> <tag>line-650632.kW_max</tag> <svar>Group40Var2</svar> <evar>Group41Var2</evar> <class>Class1</class> </input> </outstation> </dnp3> <io name=\"helics-federate\"> <broker-endpoint>127.0.0.1</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kVAR</key> <type>double</type> <tag>line-650632.kVAR</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io> </ot-sim>","title":"Overcurrent Protection Relay"},{"location":"getting_started/","text":"Getting Started \u00b6 Clone OT-sim from the repo . Building \u00b6 Requirements \u00b6 Debian-based Linux (recommend Ubuntu 20.04 LTS or greater) golang v1.18 or greater build-essential cmake v3.11 or greater libboost-dev libczmq-dev libxml2-dev libzmq5-dev pkg-config python3-dev python3-pip Install apt Packages \u00b6 sudo apt update && sudo apt install \\ build-essential cmake libboost-dev libczmq-dev libxml2-dev libzmq5-dev pkg-config python3-dev python3-pip Install Golang \u00b6 wget -O go.tgz https://golang.org/dl/go1.18.linux-amd64.tar.gz \\ && sudo tar -C /usr/local -xzf go.tgz && rm go.tgz Install OT-sim \u00b6 Install the OT-sim C, C++, and Golang modules. cmake -S . -B build && sudo cmake --build build --target install && sudo ldconfig make -C src/go dev-install Install the OT-sim Python modules. This step will also install the Python HELICS code, on which some of the OT-sim Python modules depend. sudo python3 -m pip install src/python Optional Installations \u00b6 Hivemind \u00b6 wget -O hivemind.gz https://github.com/DarthSim/hivemind/releases/download/v1.1.0/hivemind-v1.1.0-linux-amd64.gz \\ && gunzip hivemind.gz \\ && sudo mv hivemind /usr/local/bin/hivemind \\ && sudo chmod +x /usr/local/bin/hivemind Overmind \u00b6 RUN wget -O overmind.gz https://github.com/DarthSim/overmind/releases/download/v2.2.2/overmind-v2.2.2-linux-amd64.gz \\ && gunzip overmind.gz \\ && sudo mv overmind /usr/local/bin/overmind \\ && chmod +x /usr/local/bin/overmind PyModbus \u00b6 python3 -m pip install pymodbus prompt_toolkit pygments OpenDSS \u00b6 python3 -m pip install opendssdirect.py~=0.6.1 Running an Example \u00b6 If you have a Procfile-compatible tool, such as Overmind or Hivemind , you can use it to run the Procfile in the root directory. For a complete example, you will need something like the pymodbus.console to interact with the Modbus module that is run as part of the example. From one terminal or tmux pane, run the following: overmind start -D -f Procfile.single In a separate terminal or tmux pane, run the following: pymodbus.console tcp --host 127.0.0.1 --port 5502 From within the PyModbus console, you can read from holding register 30000 to get the bus voltage value. PyModbus example: > client.read_input_registers address=30000 count=1 { \"registers\": [ 98 ] } Register 30000 is configured to be scaled by a factor of two, so given the above example the actual value in the experiment is 0.98. You can trip the line feeding the bus by doing a coil write with a value of 0 to address 0 . When you read a second time, the holding register 30000 will update to 0 . PyModbus example: > client.write_coil address=0 value=0 { \"address\": 0, \"value\": false } > client.read_input_registers address=30000 count=1 { \"registers\": [ 0 ] } DNP3 Example with Docker \u00b6 First, build the Docker image. docker build -t ot-sim . Then start a container running all the modules, including the HELICS I/O module and the DNP3 module, in outstation mode. docker run -it --rm --name ot-test ot-sim hivemind Procfile.single Note You can also run a multi-device configuration, where one device acts as a DNP3 outstation to the Modbus client gateway by using Procfile.multi instead of Procfile.single above. In this configuration, when you send the DNP3 CROB command below, it is translated to a Modbus message and sent along to the second device to modify the HELICS I/O module. Next, from another terminal or tmux pane exec into the container and execute the test DNP3 master, which will do a Class 0 scan, then send a CROB command to trip a line in the OpenDSS HELICS federate that is also running, then do another Class 0 scan. docker exec -it ot-test sh -c \"cd testing/dnp3 && python3 master.py\"","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Clone OT-sim from the repo .","title":"Getting Started"},{"location":"getting_started/#building","text":"","title":"Building"},{"location":"getting_started/#requirements","text":"Debian-based Linux (recommend Ubuntu 20.04 LTS or greater) golang v1.18 or greater build-essential cmake v3.11 or greater libboost-dev libczmq-dev libxml2-dev libzmq5-dev pkg-config python3-dev python3-pip","title":"Requirements"},{"location":"getting_started/#install-apt-packages","text":"sudo apt update && sudo apt install \\ build-essential cmake libboost-dev libczmq-dev libxml2-dev libzmq5-dev pkg-config python3-dev python3-pip","title":"Install apt Packages"},{"location":"getting_started/#install-golang","text":"wget -O go.tgz https://golang.org/dl/go1.18.linux-amd64.tar.gz \\ && sudo tar -C /usr/local -xzf go.tgz && rm go.tgz","title":"Install Golang"},{"location":"getting_started/#install-ot-sim","text":"Install the OT-sim C, C++, and Golang modules. cmake -S . -B build && sudo cmake --build build --target install && sudo ldconfig make -C src/go dev-install Install the OT-sim Python modules. This step will also install the Python HELICS code, on which some of the OT-sim Python modules depend. sudo python3 -m pip install src/python","title":"Install OT-sim"},{"location":"getting_started/#optional-installations","text":"","title":"Optional Installations"},{"location":"getting_started/#hivemind","text":"wget -O hivemind.gz https://github.com/DarthSim/hivemind/releases/download/v1.1.0/hivemind-v1.1.0-linux-amd64.gz \\ && gunzip hivemind.gz \\ && sudo mv hivemind /usr/local/bin/hivemind \\ && sudo chmod +x /usr/local/bin/hivemind","title":"Hivemind"},{"location":"getting_started/#overmind","text":"RUN wget -O overmind.gz https://github.com/DarthSim/overmind/releases/download/v2.2.2/overmind-v2.2.2-linux-amd64.gz \\ && gunzip overmind.gz \\ && sudo mv overmind /usr/local/bin/overmind \\ && chmod +x /usr/local/bin/overmind","title":"Overmind"},{"location":"getting_started/#pymodbus","text":"python3 -m pip install pymodbus prompt_toolkit pygments","title":"PyModbus"},{"location":"getting_started/#opendss","text":"python3 -m pip install opendssdirect.py~=0.6.1","title":"OpenDSS"},{"location":"getting_started/#running-an-example","text":"If you have a Procfile-compatible tool, such as Overmind or Hivemind , you can use it to run the Procfile in the root directory. For a complete example, you will need something like the pymodbus.console to interact with the Modbus module that is run as part of the example. From one terminal or tmux pane, run the following: overmind start -D -f Procfile.single In a separate terminal or tmux pane, run the following: pymodbus.console tcp --host 127.0.0.1 --port 5502 From within the PyModbus console, you can read from holding register 30000 to get the bus voltage value. PyModbus example: > client.read_input_registers address=30000 count=1 { \"registers\": [ 98 ] } Register 30000 is configured to be scaled by a factor of two, so given the above example the actual value in the experiment is 0.98. You can trip the line feeding the bus by doing a coil write with a value of 0 to address 0 . When you read a second time, the holding register 30000 will update to 0 . PyModbus example: > client.write_coil address=0 value=0 { \"address\": 0, \"value\": false } > client.read_input_registers address=30000 count=1 { \"registers\": [ 0 ] }","title":"Running an Example"},{"location":"getting_started/#dnp3-example-with-docker","text":"First, build the Docker image. docker build -t ot-sim . Then start a container running all the modules, including the HELICS I/O module and the DNP3 module, in outstation mode. docker run -it --rm --name ot-test ot-sim hivemind Procfile.single Note You can also run a multi-device configuration, where one device acts as a DNP3 outstation to the Modbus client gateway by using Procfile.multi instead of Procfile.single above. In this configuration, when you send the DNP3 CROB command below, it is translated to a Modbus message and sent along to the second device to modify the HELICS I/O module. Next, from another terminal or tmux pane exec into the container and execute the test DNP3 master, which will do a Class 0 scan, then send a CROB command to trip a line in the OpenDSS HELICS federate that is also running, then do another Class 0 scan. docker exec -it ot-test sh -c \"cd testing/dnp3 && python3 master.py\"","title":"DNP3 Example with Docker"},{"location":"io/","text":"I/O Module \u00b6 Configuration Example \u00b6 Example section from configuration file: <io name=\"ot-sim-io\"> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> <broker-endpoint>localhost</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kVAR</key> <type>double</type> <tag>line-650632.kVAR</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <subscription> <key>OpenDSS/switch-671692.closed</key> <type>boolean</type> <tag>switch-671692.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io> HELICS Federate \u00b6 The OT-sim I/O Module is always a HELICS federate. In the example above , the I/O Module subscribes to data published out of an OpenDSS federate in a HELIC co-simulation. The HELICS type (s) supported in this module is boolean and double (the latter is synonymous with float). The tag key is OT-sim's term and is used on the internal message bus. The tag is similar to HELIC's term topic . If a tag is not specified, then OT-sim will use the key . The HELICS key is what HELICS will use to process the message. The pull- and pub-endpoint (s) are optional for the io configuration keys. It is possible to define an alternative internal message bus if you want to talk to a different one from the default in the Message Bus . The federate-name key is optional; if not provided, the name value in the io key will be used.","title":"I/O Module"},{"location":"io/#io-module","text":"","title":"I/O Module"},{"location":"io/#configuration-example","text":"Example section from configuration file: <io name=\"ot-sim-io\"> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> <broker-endpoint>localhost</broker-endpoint> <federate-name>ot-sim-io</federate-name> <subscription> <key>OpenDSS/bus-692.voltage</key> <type>double</type> <tag>bus-692.voltage</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kW</key> <type>double</type> <tag>line-650632.kW</tag> </subscription> <subscription> <key>OpenDSS/line-650632.kVAR</key> <type>double</type> <tag>line-650632.kVAR</tag> </subscription> <subscription> <key>OpenDSS/line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </subscription> <subscription> <key>OpenDSS/switch-671692.closed</key> <type>boolean</type> <tag>switch-671692.closed</tag> </subscription> <publication> <key>line-650632.closed</key> <type>boolean</type> <tag>line-650632.closed</tag> </publication> </io>","title":"Configuration Example"},{"location":"io/#helics-federate","text":"The OT-sim I/O Module is always a HELICS federate. In the example above , the I/O Module subscribes to data published out of an OpenDSS federate in a HELIC co-simulation. The HELICS type (s) supported in this module is boolean and double (the latter is synonymous with float). The tag key is OT-sim's term and is used on the internal message bus. The tag is similar to HELIC's term topic . If a tag is not specified, then OT-sim will use the key . The HELICS key is what HELICS will use to process the message. The pull- and pub-endpoint (s) are optional for the io configuration keys. It is possible to define an alternative internal message bus if you want to talk to a different one from the default in the Message Bus . The federate-name key is optional; if not provided, the name value in the io key will be used.","title":"HELICS Federate"},{"location":"logic/","text":"Logic Module \u00b6 Configuration Example \u00b6 Example section from configuration file: <logic> <period>1s</period> <program> <![CDATA[ counter = (counter + 1) * reset reset = counter == 50 ? 0 : 1 ]]> </program> <variables> <counter>0</counter> <reset>1</reset> </variables> </logic> In this example, we run a simple counter incrementing from 0 to 50 and then resetting and starting over. There are three keys in this particular configuration: period is the time between each program execution program is the program code variables is where variables in the program code are defined Note Variable names used in logic program code have limitations in terms of characters they can contain that may prevent users from referencing tags published by other modules. Therefore, variable definitions can include a tag attribute to reference what tag should be mapped to the variable. Note Please visit the Expr package Language Definition page for information on all of the possible syntaxes available in Logic Modules. In addition, various functions and calculations are available for configuration. Logic Module Overview \u00b6 Additional Documentation Required This page requires additional content to be added to properly document the logic module. Specifically, additional functions included above and beyond what's available by default in the Expr package need to be documented, as well as a description of the known capabilities and limitations. Hint Until additional content is added here, take a look at the Example Devices page for examples of how the logic module can be used.","title":"Logic Module"},{"location":"logic/#logic-module","text":"","title":"Logic Module"},{"location":"logic/#configuration-example","text":"Example section from configuration file: <logic> <period>1s</period> <program> <![CDATA[ counter = (counter + 1) * reset reset = counter == 50 ? 0 : 1 ]]> </program> <variables> <counter>0</counter> <reset>1</reset> </variables> </logic> In this example, we run a simple counter incrementing from 0 to 50 and then resetting and starting over. There are three keys in this particular configuration: period is the time between each program execution program is the program code variables is where variables in the program code are defined Note Variable names used in logic program code have limitations in terms of characters they can contain that may prevent users from referencing tags published by other modules. Therefore, variable definitions can include a tag attribute to reference what tag should be mapped to the variable. Note Please visit the Expr package Language Definition page for information on all of the possible syntaxes available in Logic Modules. In addition, various functions and calculations are available for configuration.","title":"Configuration Example"},{"location":"logic/#logic-module-overview","text":"Additional Documentation Required This page requires additional content to be added to properly document the logic module. Specifically, additional functions included above and beyond what's available by default in the Expr package need to be documented, as well as a description of the known capabilities and limitations. Hint Until additional content is added here, take a look at the Example Devices page for examples of how the logic module can be used.","title":"Logic Module Overview"},{"location":"message_bus/","text":"Message Bus \u00b6 Configuration Example \u00b6 Example section from configuration file: <message-bus> <verbose>1</verbose> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> </message-bus> The pull- and pub-endpoint (s) are required for the message-bus configuration keys. It is possible to define an alternative internal message bus if you want to talk to a different one; this can be configured in the I/O Module . If you want to break out each module to a separate configuration file, you will need to specify the pull- and pub-endpoint (s) as set in the Message Bus configuration. Message Bus Overview \u00b6 The Message Bus is how all of the modules communicate with each other. It uses ZeroMQ in two ways: Push and pull Publication and Subscribe (pub/sub) There are three main topics with pub/sub: RUNTIME LOG HEALTH RUNTIME \u00b6 RUNTIME is the primary topic: it is where modules will push their status and update messages for other modules to consume. There are different message formats and accompanied schemas. The first is published statuses \u2014 these are point status updates. The second is published updates . Tip See an example here for status, updates, and envelope schemas, followed by a message example. Status Message \u00b6 An example of a status message would be where an I/O module receives a message from another federate and then publishes a point status message onto the message bus for others to consume. In this case, another federate running OpenDSS, for example, is configured to publish data about line flows and breaker status. The I/O module can subscribe to line flow published by OpenDSS, and when it receives a published update it takes the value and publishes a point status message onto the message bus. Update Message \u00b6 An update message includes a value mapped to a tag on a module. For example, an I/O module is configured to look for a message and then publish it to other federates. Other modules may respond with their update. Commonalities and Differences \u00b6 All modules receive all messages. But only those with the tag(s) in the message are configured to process the message. An update to their databases follows this. Both message formats include \"who\" they were created by. Update messages can also include the destination module and a request for confirmation from the destination module once the update is processed. LOG \u00b6 Log messages pushed to the LOG topic should \u2014 at the moment \u2014 be simple string messages \u2014 no outer envelope is needed. The LOG topic is processed by the CPU module, which will then copy any logs written to the topic to the logs the CPU module generates verbatim. Note The CPU module will not prepend log messages with the name of the module that generated them, so it is recommended that the module generating the log message include its name as part of the message. HEALTH \u00b6 Currently, the HEALTH topic is used for reporting metrics from modules for the CPU module to process and make available via a Prometheus HTTP exporter listening on port 9100. OT-sim supports two types of metrics at the moment: counters and gauges. Each metric has a name, and modules generating metrics are required to ensure metric names are namespaced to avoid name collisions with metrics from other modules. Namespacing a metric name is typically done by prepending the metric name with the module name. Note Refer to the Prometheus Documentation to learn more about counters and gauges.","title":"Message Bus"},{"location":"message_bus/#message-bus","text":"","title":"Message Bus"},{"location":"message_bus/#configuration-example","text":"Example section from configuration file: <message-bus> <verbose>1</verbose> <pull-endpoint>tcp://127.0.0.1:1011</pull-endpoint> <pub-endpoint>tcp://127.0.0.1:1213</pub-endpoint> </message-bus> The pull- and pub-endpoint (s) are required for the message-bus configuration keys. It is possible to define an alternative internal message bus if you want to talk to a different one; this can be configured in the I/O Module . If you want to break out each module to a separate configuration file, you will need to specify the pull- and pub-endpoint (s) as set in the Message Bus configuration.","title":"Configuration Example"},{"location":"message_bus/#message-bus-overview","text":"The Message Bus is how all of the modules communicate with each other. It uses ZeroMQ in two ways: Push and pull Publication and Subscribe (pub/sub) There are three main topics with pub/sub: RUNTIME LOG HEALTH","title":"Message Bus Overview"},{"location":"message_bus/#runtime","text":"RUNTIME is the primary topic: it is where modules will push their status and update messages for other modules to consume. There are different message formats and accompanied schemas. The first is published statuses \u2014 these are point status updates. The second is published updates . Tip See an example here for status, updates, and envelope schemas, followed by a message example.","title":"RUNTIME"},{"location":"message_bus/#status-message","text":"An example of a status message would be where an I/O module receives a message from another federate and then publishes a point status message onto the message bus for others to consume. In this case, another federate running OpenDSS, for example, is configured to publish data about line flows and breaker status. The I/O module can subscribe to line flow published by OpenDSS, and when it receives a published update it takes the value and publishes a point status message onto the message bus.","title":"Status Message"},{"location":"message_bus/#update-message","text":"An update message includes a value mapped to a tag on a module. For example, an I/O module is configured to look for a message and then publish it to other federates. Other modules may respond with their update.","title":"Update Message"},{"location":"message_bus/#commonalities-and-differences","text":"All modules receive all messages. But only those with the tag(s) in the message are configured to process the message. An update to their databases follows this. Both message formats include \"who\" they were created by. Update messages can also include the destination module and a request for confirmation from the destination module once the update is processed.","title":"Commonalities and Differences"},{"location":"message_bus/#log","text":"Log messages pushed to the LOG topic should \u2014 at the moment \u2014 be simple string messages \u2014 no outer envelope is needed. The LOG topic is processed by the CPU module, which will then copy any logs written to the topic to the logs the CPU module generates verbatim. Note The CPU module will not prepend log messages with the name of the module that generated them, so it is recommended that the module generating the log message include its name as part of the message.","title":"LOG"},{"location":"message_bus/#health","text":"Currently, the HEALTH topic is used for reporting metrics from modules for the CPU module to process and make available via a Prometheus HTTP exporter listening on port 9100. OT-sim supports two types of metrics at the moment: counters and gauges. Each metric has a name, and modules generating metrics are required to ensure metric names are namespaced to avoid name collisions with metrics from other modules. Namespacing a metric name is typically done by prepending the metric name with the module name. Note Refer to the Prometheus Documentation to learn more about counters and gauges.","title":"HEALTH"},{"location":"modbus/","text":"Modbus Module \u00b6 Configuration Example \u00b6 Example section from configuration file: <modbus name=\"outstation\" mode=\"server\"> <endpoint>127.0.0.1:5502</endpoint> <register type=\"input\"> <address>30000</address> <tag>counter</tag> </register> <register type=\"input\"> <address>30001</address> <tag>bus-692.voltage</tag> <scaling>-2</scaling> </register> <register type=\"input\"> <address>30002</address> <tag>line-650632.kW</tag> <scaling>-2</scaling> </register> <register type=\"holding\"> <address>40000</address> <tag>reset</tag> </register> <register type=\"holding\"> <address>40001</address> <tag>line-650632.closed</tag> </register> </modbus> These configuration keys are described below . Note Please refer to the Modbus Organization for more information on the spec. Modbus Module Overview \u00b6 OT-sim supports four Modbus types ( register type= above); input \u2014 analog, read-only holding \u2014 analog, read-write discrete \u2014 binary, read-only coil \u2014 binary, read-write It is possible to configure 10,000 registers per type. In addition, the types input and holdings support scaling . Because Modbus only supports integers, scaling is used to \"move the decimal\" to the right or left. - and an integer moves the decimal to the right For example, the value 98.6 on a server with scaling of -1 will send 986 to the client + and an integer moves the decimal to the left For example, the value 986 from a server with scaling of 1 on the client will result in 98.6 on the client Note scaling must be the same absolute value for both server and client configurations. On the server it should be negative and on the client it should be positive. Note When running as a Modbus client ( <modbus mode=\"client\"> ), a developer can provide the <period> element to configure how often the Modbus client queries the remote Modbus slave for updated values. If not provided, the period defaults to 5s .","title":"Modbus Module"},{"location":"modbus/#modbus-module","text":"","title":"Modbus Module"},{"location":"modbus/#configuration-example","text":"Example section from configuration file: <modbus name=\"outstation\" mode=\"server\"> <endpoint>127.0.0.1:5502</endpoint> <register type=\"input\"> <address>30000</address> <tag>counter</tag> </register> <register type=\"input\"> <address>30001</address> <tag>bus-692.voltage</tag> <scaling>-2</scaling> </register> <register type=\"input\"> <address>30002</address> <tag>line-650632.kW</tag> <scaling>-2</scaling> </register> <register type=\"holding\"> <address>40000</address> <tag>reset</tag> </register> <register type=\"holding\"> <address>40001</address> <tag>line-650632.closed</tag> </register> </modbus> These configuration keys are described below . Note Please refer to the Modbus Organization for more information on the spec.","title":"Configuration Example"},{"location":"modbus/#modbus-module-overview","text":"OT-sim supports four Modbus types ( register type= above); input \u2014 analog, read-only holding \u2014 analog, read-write discrete \u2014 binary, read-only coil \u2014 binary, read-write It is possible to configure 10,000 registers per type. In addition, the types input and holdings support scaling . Because Modbus only supports integers, scaling is used to \"move the decimal\" to the right or left. - and an integer moves the decimal to the right For example, the value 98.6 on a server with scaling of -1 will send 986 to the client + and an integer moves the decimal to the left For example, the value 986 from a server with scaling of 1 on the client will result in 98.6 on the client Note scaling must be the same absolute value for both server and client configurations. On the server it should be negative and on the client it should be positive. Note When running as a Modbus client ( <modbus mode=\"client\"> ), a developer can provide the <period> element to configure how often the Modbus client queries the remote Modbus slave for updated values. If not provided, the period defaults to 5s .","title":"Modbus Module Overview"},{"location":"modules/","text":"Module Development \u00b6 OT-sim's modular architecture allows for the use of various programming languages for module development. As long as the programming language has a ZeroMQ implementation, programmers can use it to develop an OT-sim module. Currently, the core OT-sim project leverages four separate programming languages: C, C++, Go, and Python. It also includes implementations of an interface to access the message bus in C++, Go, and Python, all of which are structured and operate similarly. Custom OT-sim modules do not have to be developed within the framework of the core OT-sim project. As long as they are executables, can talk to the message bus using ZeroMQ, and can parse and generate the message schemas currently used by OT-sim, they should work as a module. Message Bus Interfaces \u00b6 As mentioned above, the core OT-sim project implements message bus utilities in C++, Go, and Python to simplify the development of custom OT-sim modules. These utilities include a message bus pusher, a message bus subscriber, and a metrics pusher. Message Bus Pusher \u00b6 This straightforward utility connects to the message bus using the PUSH socket type and pushes messages to a given topic. The goal of this utility is to cleanly manage the ZeroMQ socket used to interact with the message bus. Message Bus Subscriber \u00b6 This utility connects to the message bus using the SUB socket type, setting the topic to subscribe to and running as a separate thread to receive and process messages pushed to the message bus by other modules. In addition, users of this utility register a callback function for status and update messages to be called anytime the subscriber thread receives a message. The goal of this utility is to cleanly manage the ZeroMQ socket used to interact with the message bus and run as a separate thread without the developer having to worry about implementing the thread specifics. Metrics Pusher \u00b6 This utility provides methods for registering and updating metrics and periodically pushing registered metrics to the HEALTH topic on the message bus. This utility aims to provide an easily accessible metrics registry and create and manage a separate thread that periodically publishes metrics without the developer having to worry about implementing the thread specifics. Module Execution and Logging \u00b6 The CPU module provided by the core OT-sim project is capable of, but not required to, starting other OT-sim modules, monitoring them, and restarting them if they happen to die. If a developer anticipates always letting the CPU module start and monitor their custom OT-sim module, they can generate logs by simply writing to STDOUT or STDERR. The CPU module will monitor STDOUT and STDERR for the process and copy anything written to the logs it generates. Suppose a developer does not anticipate always letting the CPU module start their custom module. In that case, they can push log messages to the LOG message bus topic, and the CPU will copy anything pushed to this topic to the logs it is generating. Log messages pushed to the LOG topic should, at the moment, be simple string messages \u2014 i.e., no outer envelope is needed. Module Metrics \u00b6 Module developers that wish to expose metrics for their module can use the metrics pusher utility to register and update metrics and periodically push registered metrics to the message bus for the CPU module to process. Metrics must be registered prior to being updated, but can be registered before or after starting the thread that will periodically push them. Example Examples of registering metrics can be found here (C++) , here (Go) , and here (Python) . Examples of updating metrics can be found here (C++) , here (Go) , and here (Python) . Message Exchange \u00b6 Modules exchange messages via the message bus using a limited number of message types or schemas encoded as JSON strings. Each message exchanged is contained within a message envelope whose schema is known by all modules and identifies the type of message included. Each module can determine how to decode the message within the envelope with this information. Modules should push these messages to the RUNTIME message bus topic. The current approach to message generation is as follows: Status messages are generated and published to let other modules know about the device's current state or the system it is monitoring. Update messages are generated and published when a module needs another module to actively modify the current state of the device or system it monitors. For example, the I/O module, a HELICS federate, generates status messages whenever it gets updates from other HELICS federates. It subscribes only to update messages from other modules and propagates any updates received out to other HELICS federates. Similarly, the DNP3 module, when running in server mode, subscribes only to status messages from other modules and updates its internal DNP3 register database when new status messages are received. In addition, it generates update messages for additional modules to react to when a DNP3 client sends a control request. Message Schemas \u00b6 The envelope schema exchanges messages between modules via the RUNTIME and HEALTH topics. Envelope Schema \u00b6 type: object required: - version - kind - metadata - contents properties: version: type: string default: v1 enum: - v1 kind: type: string enum: - Status - Update - Metric metadata: type: object required: - sender additionalProperties: type: string contents: oneOf: - Status - Update RUNTIME \u00b6 Currently, only two types of messages are exchanged via the RUNTIME topic within the well-known envelope schema: Status and Update . Status Schema \u00b6 type: object required: - measurements properties: measurements: type: array items: type: object required: - tag - value - ts properties: tag: type: string value: type: number format: double ts: type: integer format: uint64 Update Schema \u00b6 type: object required: - updates properties: updates: type: array items: type: object required: - tag - value - ts properties: tag: type: string value: type: number format: double ts: type: integer format: uint64 recipient: type: string confirm: type: string Example Status Message \u00b6 { \"version\": \"v1\", \"kind\": \"Status\", \"metadata\": { \"sender\": \"ot-sim-io\" }, \"contents\": { \"measurements\": [ { \"tag\": \"bus-692.voltage\", \"value\": 1.046, \"ts\": 1657226316 }, { \"tag\": \"line-650632.closed\", \"value\": 1.0, \"ts\": 1657226316 } ] } } HEALTH \u00b6 Currently, only one type of message is exchanged via the HEALTH topic within the well-known envelope schema: Metric . Metric Schema \u00b6 type: object required: - kind - name - desc - value properties: kind: type: string enum: - Counter - Gauge name: type: string desc: type: string value: type: number format: double","title":"Module Development"},{"location":"modules/#module-development","text":"OT-sim's modular architecture allows for the use of various programming languages for module development. As long as the programming language has a ZeroMQ implementation, programmers can use it to develop an OT-sim module. Currently, the core OT-sim project leverages four separate programming languages: C, C++, Go, and Python. It also includes implementations of an interface to access the message bus in C++, Go, and Python, all of which are structured and operate similarly. Custom OT-sim modules do not have to be developed within the framework of the core OT-sim project. As long as they are executables, can talk to the message bus using ZeroMQ, and can parse and generate the message schemas currently used by OT-sim, they should work as a module.","title":"Module Development"},{"location":"modules/#message-bus-interfaces","text":"As mentioned above, the core OT-sim project implements message bus utilities in C++, Go, and Python to simplify the development of custom OT-sim modules. These utilities include a message bus pusher, a message bus subscriber, and a metrics pusher.","title":"Message Bus Interfaces"},{"location":"modules/#message-bus-pusher","text":"This straightforward utility connects to the message bus using the PUSH socket type and pushes messages to a given topic. The goal of this utility is to cleanly manage the ZeroMQ socket used to interact with the message bus.","title":"Message Bus Pusher"},{"location":"modules/#message-bus-subscriber","text":"This utility connects to the message bus using the SUB socket type, setting the topic to subscribe to and running as a separate thread to receive and process messages pushed to the message bus by other modules. In addition, users of this utility register a callback function for status and update messages to be called anytime the subscriber thread receives a message. The goal of this utility is to cleanly manage the ZeroMQ socket used to interact with the message bus and run as a separate thread without the developer having to worry about implementing the thread specifics.","title":"Message Bus Subscriber"},{"location":"modules/#metrics-pusher","text":"This utility provides methods for registering and updating metrics and periodically pushing registered metrics to the HEALTH topic on the message bus. This utility aims to provide an easily accessible metrics registry and create and manage a separate thread that periodically publishes metrics without the developer having to worry about implementing the thread specifics.","title":"Metrics Pusher"},{"location":"modules/#module-execution-and-logging","text":"The CPU module provided by the core OT-sim project is capable of, but not required to, starting other OT-sim modules, monitoring them, and restarting them if they happen to die. If a developer anticipates always letting the CPU module start and monitor their custom OT-sim module, they can generate logs by simply writing to STDOUT or STDERR. The CPU module will monitor STDOUT and STDERR for the process and copy anything written to the logs it generates. Suppose a developer does not anticipate always letting the CPU module start their custom module. In that case, they can push log messages to the LOG message bus topic, and the CPU will copy anything pushed to this topic to the logs it is generating. Log messages pushed to the LOG topic should, at the moment, be simple string messages \u2014 i.e., no outer envelope is needed.","title":"Module Execution and Logging"},{"location":"modules/#module-metrics","text":"Module developers that wish to expose metrics for their module can use the metrics pusher utility to register and update metrics and periodically push registered metrics to the message bus for the CPU module to process. Metrics must be registered prior to being updated, but can be registered before or after starting the thread that will periodically push them. Example Examples of registering metrics can be found here (C++) , here (Go) , and here (Python) . Examples of updating metrics can be found here (C++) , here (Go) , and here (Python) .","title":"Module Metrics"},{"location":"modules/#message-exchange","text":"Modules exchange messages via the message bus using a limited number of message types or schemas encoded as JSON strings. Each message exchanged is contained within a message envelope whose schema is known by all modules and identifies the type of message included. Each module can determine how to decode the message within the envelope with this information. Modules should push these messages to the RUNTIME message bus topic. The current approach to message generation is as follows: Status messages are generated and published to let other modules know about the device's current state or the system it is monitoring. Update messages are generated and published when a module needs another module to actively modify the current state of the device or system it monitors. For example, the I/O module, a HELICS federate, generates status messages whenever it gets updates from other HELICS federates. It subscribes only to update messages from other modules and propagates any updates received out to other HELICS federates. Similarly, the DNP3 module, when running in server mode, subscribes only to status messages from other modules and updates its internal DNP3 register database when new status messages are received. In addition, it generates update messages for additional modules to react to when a DNP3 client sends a control request.","title":"Message Exchange"},{"location":"modules/#message-schemas","text":"The envelope schema exchanges messages between modules via the RUNTIME and HEALTH topics.","title":"Message Schemas"},{"location":"modules/#envelope-schema","text":"type: object required: - version - kind - metadata - contents properties: version: type: string default: v1 enum: - v1 kind: type: string enum: - Status - Update - Metric metadata: type: object required: - sender additionalProperties: type: string contents: oneOf: - Status - Update","title":"Envelope Schema"},{"location":"modules/#runtime","text":"Currently, only two types of messages are exchanged via the RUNTIME topic within the well-known envelope schema: Status and Update .","title":"RUNTIME"},{"location":"modules/#status-schema","text":"type: object required: - measurements properties: measurements: type: array items: type: object required: - tag - value - ts properties: tag: type: string value: type: number format: double ts: type: integer format: uint64","title":"Status Schema"},{"location":"modules/#update-schema","text":"type: object required: - updates properties: updates: type: array items: type: object required: - tag - value - ts properties: tag: type: string value: type: number format: double ts: type: integer format: uint64 recipient: type: string confirm: type: string","title":"Update Schema"},{"location":"modules/#example-status-message","text":"{ \"version\": \"v1\", \"kind\": \"Status\", \"metadata\": { \"sender\": \"ot-sim-io\" }, \"contents\": { \"measurements\": [ { \"tag\": \"bus-692.voltage\", \"value\": 1.046, \"ts\": 1657226316 }, { \"tag\": \"line-650632.closed\", \"value\": 1.0, \"ts\": 1657226316 } ] } }","title":"Example Status Message"},{"location":"modules/#health","text":"Currently, only one type of message is exchanged via the HEALTH topic within the well-known envelope schema: Metric .","title":"HEALTH"},{"location":"modules/#metric-schema","text":"type: object required: - kind - name - desc - value properties: kind: type: string enum: - Counter - Gauge name: type: string desc: type: string value: type: number format: double","title":"Metric Schema"}]}